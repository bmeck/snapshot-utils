[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/HeapSnapshot.js",
    "memberof": null,
    "longname": "lib/HeapSnapshot.js",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "content": "\n/**\n * Representation for iterating over a snapshot's Nodes and Edges.\n * The structure of a snapshot's Node and Edge is defined within the contents of the snapshot.\n */\nexport default class HeapSnapshot {\n  /**\n   * @param {SplitSnapshotProvider} provider Snapshot data provider\n   */\n  constructor(provider) {\n    /**\n     * @private\n     */\n    this.meta = provider.getMeta();\n    /**\n     * @private\n     */\n    this.Node = createNodeClass(this, provider);\n    /**\n     * @private\n     */\n    this.Edge = createEdgeClass(this, provider);\n    /**\n     * @private\n     */\n    this.provider = provider;\n  }\n  \n  /**\n   * @typedef {Object} WalkCallbacks\n   * @property {function(node: Node)} onNodeOpen callback called when a Node\n   *   is first encountered\n   * @property {function(edge: Edge)} onEdge callback called when traversing\n   *   an Edge\n   * @property {function(node: Node)} onNodeSkipped callback called when a Node\n   *   is skipped because it has already been encountered\n   * @property {function(node: Node)} onNodeClose callback called when all\n   *   children of a Node are guaranteed to have been encountered\n   */\n  \n  /**\n   * Helper function that performs a depth first pre order traversal of\n   * the nodes of a HeapSnapshot. This will only visit each Node once, but\n   * will visit all Edges of a HeapSnapshot. Since this can be a costly\n   * operation it uses an iterator to allow chunked processing.\n   * \n   * @example\n   * let walker = walk(console.log);\n   * // the iterator does not return a value it is purely a controller\n   * for (const _ of walker) {}\n   * \n   * @param {WalkCallbacks} callbacks\n   * @return {Iterator} iterator to continue walking by calling .next \n   */\n  walk({\n    onNodeOpen = Function.prototype,\n    onEdge = Function.prototype,\n    onNodeSkipped = Function.prototype,\n    onNodeClose = Function.prototype\n  }) {\n    const snapshot = this;\n    return (function* walk() {\n      // Heaps are graphs, they can contain cycles! So we use a Set to\n      // keep track of Nodes we have already seen.\n      const visited = new Set();\n      \n      // We will be keeping a list of all the Edges we need to cross\n      // still in an array.\n      const nodes_to_visit = [snapshot.getNode(0)];\n      const edge_indices = [0];\n      \n      onNodeOpen(nodes_to_visit[0]);\n      \n      do {\n        // While walking we will grab the first Edge off our list\n        const edge_index = edge_indices[edge_indices.length - 1];\n        const owner = nodes_to_visit[nodes_to_visit.length - 1];\n        if (edge_index === owner.fields.edge_count) {\n          onNodeClose(owner);\n          yield;\n          nodes_to_visit.pop();\n          edge_indices.pop();\n          continue;\n        }\n        else {\n          edge_indices[edge_indices.length - 1] += 1;\n        }\n        const edge_to_walk = owner.getEdge(edge_index);\n        \n        onEdge(edge_to_walk);\n        yield;\n        \n        // We grab the Node that this edge points to\n        const node = edge_to_walk.getNode();\n        \n        // We want to be sure we don't start a cycle so we skip\n        // Nodes we have already visited (but not Edges to those Nodes\n        // in this example)\n        if (visited.has(node.node_index)) {\n          onNodeSkipped(node);\n          continue;\n        }\n        visited.add(node.node_index);\n        \n        // Add all of the edges of a node to the list of Edges we\n        // need to visit\n        nodes_to_visit.push(node);\n        edge_indices.push(0);\n        \n        onNodeOpen(node);\n        yield;\n      }\n      while (nodes_to_visit.length);\n    })();\n  }\n  \n  /**\n   * Walks over all the Samples in the HeapSnapshot in order.\n   * \n   * @return {Iterator<Sample>} Iterator to walk over all of the Samples. \n   */\n  samples() {\n    const snapshot = this;\n    return function* samples() {\n      const samples_arr_length = snapshot.provider.getSampleArraySize();\n      for (let i = 0; i < samples_arr_length; i++) {\n        yield snapshot.getSample(i);\n      }\n    }();\n  }\n  \n  /**\n   * Gets a Sample by index.\n   * \n   * @example\n   * const first = snapshot.getSample(0);\n   * const second = snapshot.getSample(1);\n   * console.log('delay', second.time - first.time);\n   * \n   * @param {number} sample_index\n   * @return {Sample}\n   */\n  getSample(sample_index) {\n    if (sample_index > this.provider.getSampleArraySize()) {\n      return null;\n    }\n    const sample_buffer = this.provider.getSampleBuffer(sample_index);\n    const sample = new Sample(sample_buffer);\n    return sample;\n  }\n\n  /**\n   * @typedef {Object} NodeResult\n   * @property {Node} fields\n   * @property {number} node_index Index that can be used with getNode to get this Node.\n   * @property {number} edge_index Index that can be used to get the first Edge of this Node.\n   * @property {function(index: Number):EdgeResult} getEdge Get the specified Edge of this node.\n   * @property {function():EdgeIterator} walkEdges Helper for iterating the edges of a Node.\n   */\n  /**\n   * Gets a Node by index, not by ID. The root Node is at index 0.\n   *\n   * @example\n   * const root = snapshot.getNode(0);\n   *\n   * @param {number} node_index\n   * @return {NodeResult}\n   */\n  getNode(node_index) {\n    if (node_index > this.provider.getNodeArraySize()) {\n      return null;\n    }\n    const node_buffer = this.provider.getNodeBuffer(node_index);\n    const node = new this.Node(node_buffer);\n    const edge_index = node_buffer.readUInt32BE(node_buffer.length - 4);\n    const self = this;\n    return {\n      fields: node,\n      node_index,\n      edge_index,\n      getEdge(i) {\n        const edge_count = node.edge_count;\n        if (i > edge_count) {\n          throw new RangeError('invalid edge number');\n        }\n        const edge_size = self.meta.edge_fields.length;\n        const index = (edge_index + i) * edge_size;\n        return self.getEdge(index);\n      },\n      getTrace() {\n        return {\n          id: -1,\n          line: -1,\n          column: -1\n        };\n      },\n      *walkEdges() {\n        const edge_count = node.edge_count;\n        const edge_size = self.meta.edge_fields.length;\n        for (let i = 0; i < edge_count; i++) {\n          const index = (edge_index + i) * edge_size;\n          const e = self.getEdge(index);\n          if (e != null) {\n            yield e;\n          }\n        }\n      }\n    };\n  }\n  \n  /**\n   * Gets a Node by ID. This can be *SIGNIFICANTLY SLOWER* than looking up the Node by index since IDs are sparse.\n   *\n   * @example\n   * const myNode = snapshot.getNodeById(42);\n   *\n   * @param {number} node_id\n   * @return {NodeResult}\n   */\n  getNodeById(node_id) {\n    const node_arr_length = this.provider.getNodeArraySize();\n    const node_fields_len = this.meta.node_fields.length;\n    const last = this.getNode(node_arr_length - node_fields_len);\n    // make a best guess given known distribution\n    let node_index = Math.ceil((node_id / last.fields.id) * node_arr_length) * node_fields_len;\n    const incr = this.getNode(node_index).fields.id < node_id ?\n      -node_fields_len :\n      node_fields_len;\n    while (node_index >= 0 && node_index < node_arr_length) {\n      const node = this.getNode(node_index);\n      const id = node.fields.id;\n      if (id === node_id) {\n        return node;\n      }\n      node_index += incr;\n    }\n  }\n\n  /**\n   * @typedef {Object} EdgeResult\n   * @property {Edge} fields\n   * @property {number} edge_index Index that can be used with getEdge to get this Edge.\n   * @property {number} node_index Index that can be used with getNode to get the owner of this Edge.\n   * @property {function():NodeResult} getNode Helper for getting the Node this Edge points to.\n   */\n  /**\n   * Gets an Edge by index. This should only be used in conjuction with a Node object.\n   * @private\n   * @param {number} edge_index Index of the Edge we wish to get a hold of.\n   * @return {EdgeResult}\n   */\n  getEdge(edge_index) {\n    if (edge_index > this.provider.getEdgeArraySize()) {\n      return null;\n    }\n    const edge_buffer = this.provider.getEdgeBuffer(edge_index);\n    const fields = new this.Edge(edge_buffer);\n    const node_index = edge_buffer.readUInt32BE(edge_buffer.length - 4);\n    const self = this;\n    return {\n      fields,\n      edge_index,\n      node_index,\n      getNode() {\n        return self.getNode(fields.to_node);\n      },\n      getOwner() {\n        return self.getNode(node_index);\n      }\n    };\n  }\n}\n/**\n * @typedef Sample\n * A Sample class for a HeapSnapshot.\n * @property {number} timestamp Timestamp of this sample in nanoseconds. The first sample will generally have a timestamp of 0 and you must compute the time differences accordingly.\n * @property {number} lastAssignedId The largest `node.fields.id` visible when this sample was taken. Since `id`s only increment, all `id`s less than this were allocated prior to this sample.\n */\nexport class Sample {\n  /**\n   * @private\n   */\n  constructor(buffer) {\n    this._buffer = buffer;\n  }\n  /**\n   * @private\n   */\n  inspect() {\n      let ret = '';\n      let i = 0;\n      for (const field of ['timestamp','lastAssignedId']) {\n        ret += ' '+[field, this[field], this._buffer.slice(i * 4, i * 4 + 4).toString('hex')].join(':');\n        i++;\n      }\n      return `HeapSnapshot::Sample${ret}`;\n  }\n  /**\n   * @private\n   */\n  get timestamp() {\n    return this._buffer.readUInt32BE(0);\n  }\n  /**\n   * @private\n   */\n  get lastAssignedId() {\n    return this._buffer.readUInt32BE(4);\n  }\n}\n/**\n * Generates an Node class tailored for HeapSnapshot. These can vary between snapshots.\n * @param {HeapSnapshot} snapshot HeapSnapshot that created this Node class\n * @param {SplitSnapshotProvider} provider Our snapshot data\n */\nfunction createNodeClass(snapshot, provider) {\n  const meta = provider.getMeta();\n  class Node {\n    constructor(buffer) {\n      this._buffer = buffer;\n    }\n    inspect() {\n      let ret = '';\n      let i = 0;\n      for (const field of meta.node_fields) {\n        ret += ' '+[field, this[field], this._buffer.slice(i * 4, i * 4 + 4).toString('hex')].join(':');\n        i++;\n      }\n      return `HeapSnapshot::Node${ret}`;\n    }\n  }\n  let i = 0;\n  for (const field of meta.node_fields) {\n    let field_index = i * 4;\n    let field_type = meta.node_types[i];\n    if (Array.isArray(field_type)) {\n      if (field === 'type') {\n        // v8 bug: https://codereview.chromium.org/1450463002/#\n        field_type[0x0C] = 'symbol';\n        field_type[0x0D] = 'simd';\n      }\n      Object.defineProperty(Node.prototype, field, {\n        enumerable: true,\n        get() {\n          return field_type[this._buffer.readUInt32BE(field_index)];\n        }\n      });\n    }\n    else if (field_type === 'string') {\n      Object.defineProperty(Node.prototype, field, {\n        enumerable: true,\n        get() {\n          return provider.getString(this._buffer.readUInt32BE(field_index));\n        }\n      });\n    }\n    else {\n      Object.defineProperty(Node.prototype, field, {\n        enumerable: true,\n        get() {\n          return this._buffer.readUInt32BE(field_index);\n        }\n      });\n    }\n    i++;\n  };\n  return Node;\n}\n/**\n * Generates an Edge class tailored for HeapSnapshot. These can vary between snapshots.\n * @param {HeapSnapshot} snapshot HeapSnapshot that created this Edge class\n * @param {SplitSnapshotProvider} provider Our snapshot data\n */\nfunction createEdgeClass(snapshot, provider) {\n  const meta = provider.getMeta();\n  class Edge {\n    constructor(buffer) {\n      this._buffer = buffer;\n    }\n    inspect() {\n      let ret = '';\n      let i = 0;\n      for (const field of meta.edge_fields) {\n        ret += ' '+[field, this[field], this._buffer.slice(i * 4, i * 4 + 4).toString('hex')].join(':');\n        i++;\n      }\n      ret += ' node.id:' + snapshot.getNode(this.to_node).fields.id;\n      return `HeapSnapshot::Edge ${ret}`;\n    }\n  }\n  let i = 0;\n  for (let field of meta.edge_fields) {\n    (function(){ \n    const field_index = i * 4;\n    const field_type = meta.edge_types[i];\n    i++;\n    if (Array.isArray(field_type)) {\n      Object.defineProperty(Edge.prototype, field, {\n        enumerable: true,\n        get() {\n          return field_type[this._buffer.readUInt32BE(field_index)];\n        }\n      });\n    }\n    else if (field === 'name_or_index') {\n      Object.defineProperty(Edge.prototype, field, {\n        enumerable: true,\n        get() {\n          let value = this._buffer.readUInt32BE(field_index);\n          if (this.type !== 'element') {\n            value = provider.getString(value).toString();\n          }\n          return value;\n        }\n      });\n    }\n    else {\n      Object.defineProperty(Edge.prototype, field, {\n        enumerable: true,\n        get() {\n          return this._buffer.readUInt32BE(field_index);\n        }\n      });\n    }\n    })();\n  };\n  return Edge;\n}\nfunction createTraceFrameClass(provider) {\n  const meta = provider.getMeta();\n  class TraceFrame {\n    constructor(buffer) {\n      this._buffer = buffer;\n    }\n    parent() {\n      \n    }\n    inspect() {\n      let ret = '';\n      let i = 0;\n      for (const field of meta.trace_node_fields) {\n        ret += ' '+[field, this[field], this._buffer.slice(i * 4, i * 4 + 4).toString('hex')].join(':');\n        i++;\n      }\n      return `HeapSnapshot::TraceFrame ${ret}`;\n    }\n  }\n  let i = 0;\n  for (let field of meta.trace_node_fields) {\n    (function(){ \n      const field_index = i * 4;\n      Object.defineProperty(TraceFrame.prototype, field, {\n        enumerable: true,\n        get() {\n          return this._buffer.readUInt32BE(field_index);\n        }\n      });\n    })();\n  };\n  return TraceFrame;\n}\nfunction createTraceLocationClass(provider) {\n  const meta = provider.getMeta();\n  class TraceFrame {\n    constructor(buffer) {\n      this._buffer = buffer;\n    }\n    parent() {\n      \n    }\n    inspect() {\n      let ret = '';\n      let i = 0;\n      for (const field of meta.trace_node_fields) {\n        ret += ' '+[field, this[field], this._buffer.slice(i * 4, i * 4 + 4).toString('hex')].join(':');\n        i++;\n      }\n      return `HeapSnapshot::TraceFrame ${ret}`;\n    }\n  }\n  let i = 0;\n  for (let field of meta.trace_node_fields) {\n    (function(){ \n      const field_index = i * 4;\n      Object.defineProperty(TraceFrame.prototype, field, {\n        enumerable: true,\n        get() {\n          return this._buffer.readUInt32BE(field_index);\n        }\n      });\n    })();\n  };\n  return TraceFrame;\n}\n"
  },
  {
    "__docId__": 1,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "HeapSnapshot",
    "memberof": "lib/HeapSnapshot.js",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot",
    "access": null,
    "export": true,
    "importPath": "snapshot-utils/lib/HeapSnapshot.js",
    "importStyle": "HeapSnapshot",
    "description": "Representation for iterating over a snapshot's Nodes and Edges.\nThe structure of a snapshot's Node and Edge is defined within the contents of the snapshot.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#constructor",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "SplitSnapshotProvider"
        ],
        "spread": false,
        "optional": false,
        "name": "provider",
        "description": "Snapshot data provider"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 3,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "meta",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#meta",
    "access": "private",
    "description": null,
    "lineNumber": 14,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "Node",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#Node",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "Edge",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#Edge",
    "access": "private",
    "description": null,
    "lineNumber": 22,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "provider",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#provider",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "WalkCallbacks",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot.WalkCallbacks",
    "access": null,
    "description": null,
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(node: Node)"
        ],
        "spread": false,
        "optional": false,
        "name": "onNodeOpen",
        "description": "callback called when a Node\n  is first encountered"
      },
      {
        "nullable": null,
        "types": [
          "function(edge: Edge)"
        ],
        "spread": false,
        "optional": false,
        "name": "onEdge",
        "description": "callback called when traversing\n  an Edge"
      },
      {
        "nullable": null,
        "types": [
          "function(node: Node)"
        ],
        "spread": false,
        "optional": false,
        "name": "onNodeSkipped",
        "description": "callback called when a Node\n  is skipped because it has already been encountered"
      },
      {
        "nullable": null,
        "types": [
          "function(node: Node)"
        ],
        "spread": false,
        "optional": false,
        "name": "onNodeClose",
        "description": "callback called when all\n  children of a Node are guaranteed to have been encountered"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WalkCallbacks"
    }
  },
  {
    "__docId__": 8,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "walk",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#walk",
    "access": null,
    "description": "Helper function that performs a depth first pre order traversal of\nthe nodes of a HeapSnapshot. This will only visit each Node once, but\nwill visit all Edges of a HeapSnapshot. Since this can be a costly\noperation it uses an iterator to allow chunked processing.",
    "examples": [
      "let walker = walk(console.log);\n// the iterator does not return a value it is purely a controller\nfor (const _ of walker) {}"
    ],
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "WalkCallbacks"
        ],
        "spread": false,
        "optional": false,
        "name": "callbacks",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Iterator"
      ],
      "spread": false,
      "description": "iterator to continue walking by calling .next"
    },
    "generator": false
  },
  {
    "__docId__": 9,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "samples",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#samples",
    "access": null,
    "description": "Walks over all the Samples in the HeapSnapshot in order.",
    "lineNumber": 122,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Iterator<Sample>"
      ],
      "spread": false,
      "description": "Iterator to walk over all of the Samples."
    },
    "generator": false
  },
  {
    "__docId__": 10,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSample",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#getSample",
    "access": null,
    "description": "Gets a Sample by index.",
    "examples": [
      "const first = snapshot.getSample(0);\nconst second = snapshot.getSample(1);\nconsole.log('delay', second.time - first.time);"
    ],
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "sample_index",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Sample"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 11,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "NodeResult",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot.NodeResult",
    "access": null,
    "description": null,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Node"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "node_index",
        "description": "Index that can be used with getNode to get this Node."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "edge_index",
        "description": "Index that can be used to get the first Edge of this Node."
      },
      {
        "nullable": null,
        "types": [
          "function(index: Number):EdgeResult"
        ],
        "spread": false,
        "optional": false,
        "name": "getEdge",
        "description": "Get the specified Edge of this node."
      },
      {
        "nullable": null,
        "types": [
          "function():EdgeIterator"
        ],
        "spread": false,
        "optional": false,
        "name": "walkEdges",
        "description": "Helper for iterating the edges of a Node."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "NodeResult"
    }
  },
  {
    "__docId__": 12,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getNode",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#getNode",
    "access": null,
    "description": "Gets a Node by index, not by ID. The root Node is at index 0.",
    "examples": [
      "const root = snapshot.getNode(0);"
    ],
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "node_index",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "NodeResult"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 13,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getNodeById",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#getNodeById",
    "access": null,
    "description": "Gets a Node by ID. This can be *SIGNIFICANTLY SLOWER* than looking up the Node by index since IDs are sparse.",
    "examples": [
      "const myNode = snapshot.getNodeById(42);"
    ],
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "node_id",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "NodeResult"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 14,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "EdgeResult",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot.EdgeResult",
    "access": null,
    "description": null,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Edge"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "edge_index",
        "description": "Index that can be used with getEdge to get this Edge."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "node_index",
        "description": "Index that can be used with getNode to get the owner of this Edge."
      },
      {
        "nullable": null,
        "types": [
          "function():NodeResult"
        ],
        "spread": false,
        "optional": false,
        "name": "getNode",
        "description": "Helper for getting the Node this Edge points to."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "EdgeResult"
    }
  },
  {
    "__docId__": 15,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getEdge",
    "memberof": "lib/HeapSnapshot.js~HeapSnapshot",
    "longname": "lib/HeapSnapshot.js~HeapSnapshot#getEdge",
    "access": "private",
    "description": "Gets an Edge by index. This should only be used in conjuction with a Node object.",
    "lineNumber": 252,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "edge_index",
        "description": "Index of the Edge we wish to get a hold of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "EdgeResult"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 16,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "Sample",
    "memberof": "lib/HeapSnapshot.js",
    "longname": "lib/HeapSnapshot.js~Sample",
    "access": null,
    "description": null,
    "lineNumber": 279,
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": "Timestamp of this sample in nanoseconds. The first sample will generally have a timestamp of 0 and you must compute the time differences accordingly."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lastAssignedId",
        "description": "The largest `node.fields.id` visible when this sample was taken. Since `id`s only increment, all `id`s less than this were allocated prior to this sample."
      }
    ],
    "type": {
      "types": [
        "*"
      ],
      "optional": false,
      "name": "Sample"
    }
  },
  {
    "__docId__": 17,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createNodeClass",
    "memberof": "lib/HeapSnapshot.js",
    "longname": "lib/HeapSnapshot.js~createNodeClass",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/HeapSnapshot.js",
    "importStyle": null,
    "description": "Generates an Node class tailored for HeapSnapshot. These can vary between snapshots.",
    "lineNumber": 316,
    "params": [
      {
        "nullable": null,
        "types": [
          "HeapSnapshot"
        ],
        "spread": false,
        "optional": false,
        "name": "snapshot",
        "description": "HeapSnapshot that created this Node class"
      },
      {
        "nullable": null,
        "types": [
          "SplitSnapshotProvider"
        ],
        "spread": false,
        "optional": false,
        "name": "provider",
        "description": "Our snapshot data"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 18,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createEdgeClass",
    "memberof": "lib/HeapSnapshot.js",
    "longname": "lib/HeapSnapshot.js~createEdgeClass",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/HeapSnapshot.js",
    "importStyle": null,
    "description": "Generates an Edge class tailored for HeapSnapshot. These can vary between snapshots.",
    "lineNumber": 374,
    "params": [
      {
        "nullable": null,
        "types": [
          "HeapSnapshot"
        ],
        "spread": false,
        "optional": false,
        "name": "snapshot",
        "description": "HeapSnapshot that created this Edge class"
      },
      {
        "nullable": null,
        "types": [
          "SplitSnapshotProvider"
        ],
        "spread": false,
        "optional": false,
        "name": "provider",
        "description": "Our snapshot data"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 19,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createTraceFrameClass",
    "memberof": "lib/HeapSnapshot.js",
    "longname": "lib/HeapSnapshot.js~createTraceFrameClass",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/HeapSnapshot.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 429,
    "undocument": true,
    "params": [
      {
        "name": "provider",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 20,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createTraceLocationClass",
    "memberof": "lib/HeapSnapshot.js",
    "longname": "lib/HeapSnapshot.js~createTraceLocationClass",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/HeapSnapshot.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 462,
    "undocument": true,
    "params": [
      {
        "name": "provider",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 21,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/SplitSnapshotProvider.js",
    "memberof": null,
    "longname": "lib/SplitSnapshotProvider.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import fs from \"fs\";\nimport path from \"path\";\nimport parseSnapshotStream from \"./parseSnapshotStream\";\n\n/**\n * An implementation of working directly with snapshot data, not meant for dev consumption.\n * This implementation uses Synchronous file APIs\n */\nexport default class SplitSnapshotProvider {\n\t/**\n\t * @param {Object} snapshot_info Meta information required for understanding a snapshot\n\t * @param {Buffer} node_buffer\n\t * @param {Buffer} edge_buffer\n\t * @param {Buffer} string_indices_buffer\n\t * @param {Buffer} string_buffer\n\t */\n  constructor(\n    snapshot_info,\n    node_buffer,\n    edge_buffer,\n\tsamples_buffer,\n    string_indices_buffer,\n    string_buffer\n  ) {\n    const snapshot = snapshot_info;\n    /**\n     * @private\n     */\n    this.snapshot = snapshot;\n\t\t\n    /**\n     * @private\n     */\n    this.node_fields_length = snapshot.meta.node_fields.length;\n    /**\n     * @private\n     */\n\tthis.node_arr_length = snapshot.node_count * this.node_fields_length;\n    // append edge_buffer index to get 1st edge\n    /**\n     * @private\n     */\n\tthis.node_struct_size = this.node_fields_length * 4 + 4;\n    /**\n     * @private\n     */\n    this.node_buffer = node_buffer;\n\tif (this.node_buffer.length !== this.node_struct_size * snapshot.node_count) {\n\t\tthrow new Error('nodes buffer does not match the expected size (either number of nodes is incorrect, or structure is)');\n\t}\n\n    /**\n     * @private\n     */\n\tthis.edge_fields_length = snapshot.meta.edge_fields.length;\n    /**\n     * @private\n     */\n\tthis.edge_arr_length = snapshot.edge_count * this.edge_fields_length;\n    // prepend node_buffer index to get node\n    /**\n     * @private\n     */\n\tthis.edge_struct_size = snapshot.meta.edge_fields.length * 4 + 4;\n    /**\n     * @private\n     */\n    this.edge_buffer = edge_buffer;\n\tif (this.edge_buffer.length !== this.edge_struct_size * snapshot.edge_count) {\n\t\tthrow new Error('edges buffer does not match the expected size (either number of edges is incorrect, or structure is)')\n\t}\n\t\n\t/**\n\t * @private\n\t */\n\tthis.sample_struct_size = 4 * 2;\n\t/**\n\t * @private\n\t */\n\tthis.sample_arr_length = samples_buffer.length / this.sample_struct_size;\n\t/**\n\t * @private\n\t */\n\tthis.sample_buffer = samples_buffer;\n    \n    /**\n     * @private\n     */\n    this.string_indices_buffer = string_indices_buffer;\n    /**\n     * @private\n     */\n    this.strings_buffer = string_buffer;\n    \n    /**\n     * @private\n     */\n\tthis.string_index_struct_size = 4 + 4;\n  }\n\n\n  /**\n   * Get total number of Nodes\n   * @return {number}\n   */\n  getNodeArraySize() {\n    return this.node_arr_length;\n  }\n\n\n  /**\n   * Get the buffer for a Node at the specified index\n   * @param {number} index\n   * @return {Buffer}\n   */\n  getNodeBuffer(index) {\n    let n = index / this.node_fields_length;\n    if (n !== (n | 0)) {\n      throw new RangeError('index is not on a Node boundary');\n    }\n    let offset = n * this.node_struct_size;\n    return this.node_buffer.slice(\n      offset,\n      offset + this.node_struct_size\n    );\n  }\n\n\n  /**\n   * Get total number of Edges\n   * @return {number}\n   */\n  getEdgeArraySize() {\n    return this.edge_arr_length;\n  }\n\n\n  /**\n   * Get the buffer for an Edge at the specified index\n   * @param {number} index\n   * @return {Buffer}\n   */\n  getEdgeBuffer(index) {\n    let n = index / this.edge_fields_length;\n    if (n !== (n | 0)) {\n      throw new RangeError('index is not on a Edge boundary');\n    }\n    let offset = n * this.edge_struct_size;\n    return this.edge_buffer.slice(\n      offset,\n      offset + this.edge_struct_size\n    );\n  }\n\n\n  /**\n   * Get total number of Samples\n   * @return {number}\n   */\n  getSampleArraySize() {\n    return this.sample_arr_length;\n  }\n  \n\n  /**\n   * Gets a sample at the specified index.\n   * @param {number} index Index of the sample we wish to get.\n   * @return {string} \n   */\n  getSampleBuffer(index) {\n\t  const index_offset = index * this.sample_struct_size;\n\t  return this.sample_buffer.slice(\n\t\t  index_offset,\n\t\t  index_offset + this.sample_struct_size\n\t  );\n  }\n\n\n  /**\n   * Gets a string at the specified index.\n   * @param {number} index Index of the string we wish to get.\n   * @return {string} \n   */\n  getString(index) {\n    const index_offset = index * this.string_index_struct_size;\n    const chunk = this.string_indices_buffer.slice(\n      index_offset,\n      index_offset + this.string_index_struct_size\n    );\n    const offset = chunk.readUInt32BE(0);\n    const length = chunk.readUInt32BE(4);\n    return this.strings_buffer.slice(\n      offset,\n      offset + length\n    ).toString();\n  }\n\n  /**\n\t* @return {Object} Metadata from the snapshot data required to find Node and Field structure.\n\t*/\n  getMeta() {\n    return this.snapshot.meta;\n  }\n\t\n  /**\n   * Convenience method for saving snapshot data in a faster loading format to a directory\n   * @param {string} outdir Path of the directory to save to\n   * @param {function(err: *)} callback Callback notified when there is an error or completion\n   * @return {undefined}\n   */\n  writeToDirectory(outdir, callback) {\n\t\tconst meta_file = path.join(outdir, 'snapshot.json');\n\t\tconst nodes_file = path.join(outdir, 'nodes');\n\t\tconst edges_file = path.join(outdir, 'edges');\n\t\tconst strings_file = path.join(outdir, 'strings');\n\t\tconst string_indices_file = path.join(outdir, 'string_indices');\n\t\t\n\t\tlet todo = 5;\n\t\tfunction done(e) {\n\t\t\ttodo--;\n\t\t\tif (todo < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tcallback(e);\n\t\t\t\ttodo = 0;\n\t\t\t}\n\t\t\telse if (todo === 0) {\n\t\t\t\tcallback(null);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfs.writeFile(meta_file, this.snapshot, done);\n\t\tfs.writeFile(nodes_file, this.node_buffer, done);\n\t\tfs.writeFile(edges_file, this.edge_buffer, done);\n\t\tfs.writeFile(strings_file, this.strings_buffer, done);\n\t\tfs.writeFile(string_indices_file, this.string_indices_buffer, done);\n\t}\n\t\n  \n\t\n  /**\n   * Convenience method for loading snapshot data from a directory\n   * @param {string} outdir Path of the directory to load\n   * @param {function(err: *, provider: SplitSnapshotProvider)} callback Callback notified when there is an error or completion\n   * @return {undefined}\n   */\n\tstatic fromDirectory(outdir, callback) {\n\t\tconst meta_file = path.join(outdir, 'snapshot.json');\n\t\tconst nodes_file = path.join(outdir, 'nodes');\n\t\tconst edges_file = path.join(outdir, 'edges');\n\t\tconst samples_file = path.join(outdir, 'samples');\n\t\tconst strings_file = path.join(outdir, 'strings');\n\t\tconst string_indices_file = path.join(outdir, 'string_indices');\n\t\t\n\t\tlet todo = 6;\n\t\tlet snapshot_info;\n\t\tlet nodes_buffer;\n\t\tlet edges_buffer;\n\t\tlet samples_buffer;\n\t\tlet strings_buffer;\n\t\tlet string_indices_buffer;\n\t\tfunction done(e) {\n\t\t\ttodo--;\n\t\t\tif (todo < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tcallback(e);\n\t\t\t\ttodo = 0;\n\t\t\t}\n\t\t\telse if (todo === 0) {\n\t\t\t\tcallback(null, new SplitSnapshotProvider(\n\t\t\t\t\tsnapshot_info,\n\t\t\t\t\tnodes_buffer,\n\t\t\t\t\tedges_buffer,\n\t\t\t\t\tsamples_buffer,\n\t\t\t\t\tstring_indices_buffer,\n\t\t\t\t\tstrings_buffer\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t\tfs.readFile(meta_file, (e,b) => {\n\t\t\tif (e) {\n\t\t\t\tdone(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsnapshot_info = JSON.parse(String(b));\n\t\t\t\tdone();\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tdone(e);\n\t\t\t}\n\t\t});\n\t\tfs.readFile(nodes_file, (e,b) => {\n\t\t\tif (e) {\n\t\t\t\tdone(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnodes_buffer = b;\n\t\t\tdone();\n\t\t});\n\t\tfs.readFile(edges_file, (e,b) => {\n\t\t\tif (e) {\n\t\t\t\tdone(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tedges_buffer = b;\n\t\t\tdone();\n\t\t});\n\t\tfs.readFile(samples_file, (e,b) => {\n\t\t\tif (e) {\n\t\t\t\tdone(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsamples_buffer = b;\n\t\t\tdone();\n\t\t});\n\t\tfs.readFile(strings_file, (e,b) => {\n\t\t\tif (e) {\n\t\t\t\tdone(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstrings_buffer = b;\n\t\t\tdone();\n\t\t});\n\t\tfs.readFile(string_indices_file, (e,b) => {\n\t\t\tif (e) {\n\t\t\t\tdone(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstring_indices_buffer = b;\n\t\t\tdone();\n\t\t});\n\t}\n  \n  \n  /**\n   * Convenience method for loading snapshot data from a stream\n   * @param {Stream} stream Path of the directory to load\n   * @param {function(err: *, provider: SplitSnapshotProvider)} callback Callback notified when there is an error or completion\n   * @return {undefined}\n   */\n\tstatic fromStream(stream, callback) {\n\t\t// track this to attach to nodes\n\t\tlet edge_offset = 0;\n\t\tlet node_offset = -1;\n\t\t\n\t\tlet edge_count_field_offset = 0;\n\t\t\n\t\tlet snapshot_info = null;\n\t\tlet nodes_buffer_index = 0;\n\t\tlet nodes_buffer = null;\n\t\tlet edges_buffer_index = 0;\n\t\tlet edges_buffer = null;\n\t\tlet samples_buffer_length = 0;\n\t\tlet samples_buffer = new Buffer(0);\n\t\tlet strings_buffer_length = 0;\n\t\tlet strings_buffer = null;\n\t\tlet strings_indices_buffer_length = 0;\n\t\tlet strings_indices_buffer = null;\n\t\t\n\t\tlet node_struct_size = 0;\n\t\t\n\t\tstream.pipe(parseSnapshotStream({\n\t\t\tonsnapshot_info(snapshot) {\n\t\t\t\tedge_count_field_offset = snapshot.meta.node_fields.indexOf('edge_count') * 4;\n\t\t\t\tsnapshot_info = snapshot;\n\t\t\t\tconst node_fields_length = snapshot.meta.node_fields.length;\n\t\t\t\t// append edge_buffer index to get 1st edge\n\t\t\t\tnode_struct_size = node_fields_length * 4 + 4;\n\t\t\t\tnodes_buffer = new Buffer(node_struct_size * snapshot.node_count);\n\t\t\t\n\t\t\t\t// prepend node_buffer index to get node\n\t\t\t\tconst edge_struct_size = snapshot.meta.edge_fields.length * 4 + 4;\n\t\t\t\tedges_buffer = new Buffer(edge_struct_size * snapshot.edge_count);\n\t\t\t\t\n\t\t\t\tstrings_indices_buffer = new Buffer(4 * 1024);\n\t\t\t\tstrings_buffer = new Buffer(4 * 1024);\n\t\t\t},\n\t\t\tonnode(buffer) {\n\t\t\t\tif (buffer == null) {\n\t\t\t\t\tedge_offset = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbuffer.copy(nodes_buffer, nodes_buffer_index);\n\t\t\t\tnodes_buffer_index += buffer.length;\n\t\t\t\tnodes_buffer.writeUInt32BE(edge_offset, nodes_buffer_index);\n\t\t\t\tnodes_buffer_index += 4;\n\t\t\t\tconst edge_count = buffer.readUInt32BE(edge_count_field_offset);\n\t\t\t\tedge_offset += edge_count;\n\t\t\t},\n\t\t\tonedge(buffer) {\n\t\t\t\tif (buffer == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbuffer.copy(edges_buffer, edges_buffer_index);\n\t\t\t\tedges_buffer_index += buffer.length;\n\t\t\t\tif (edge_offset == 0) {\n\t\t\t\t\tnode_offset++;\n\t\t\t\t\tedge_offset = nodes_buffer.readUInt32BE(node_struct_size * node_offset + edge_count_field_offset);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tedge_offset--;\n\t\t\t\t}\n\t\t\t\tedges_buffer.writeUInt32BE(node_offset * node_struct_size, edges_buffer_index);\n\t\t\t\tedges_buffer_index += 4;\n\t\t\t},\n\t\t\tonsample(buffer) {\n\t\t\t\tif (buffer == null) {\n\t\t\t\t\tsamples_buffer = samples_buffer.slice(0, samples_buffer_length);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (samples_buffer.length - samples_buffer_length < 8) {\n\t\t\t\t\tsamples_buffer = Buffer.concat([samples_buffer, new Buffer(4096)]);\n\t\t\t\t}\n\t\t\t\tbuffer.copy(samples_buffer, samples_buffer_length);\n\t\t\t\tsamples_buffer_length += buffer.length;\n\t\t\t},\n\t\t\tonstring(str) {\n\t\t\t\tif (str == null) {\n\t\t\t\t\tstrings_indices_buffer = strings_indices_buffer.slice(0, strings_indices_buffer_length);\n\t\t\t\t\tstrings_buffer = strings_buffer.slice(0, strings_buffer_length);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// enforce utf8 encoding\n\t\t\t\tlet str_buf = new Buffer(str, 'utf8');\n\t\t\t\tlet str_buf_length = str_buf.length;\n\t\t\t\t\n\t\t\t\tif (strings_indices_buffer.length - strings_indices_buffer_length < 8) {\n\t\t\t\t\tstrings_indices_buffer = Buffer.concat([strings_indices_buffer, new Buffer(4096)]);\n\t\t\t\t}\n\t\t\t\tstrings_indices_buffer.writeUInt32BE(strings_buffer_length, strings_indices_buffer_length);\n\t\t\t\tstrings_indices_buffer_length += 4;\n\t\t\t\tstrings_indices_buffer.writeUInt32BE(str_buf_length, strings_indices_buffer_length);\n\t\t\t\tstrings_indices_buffer_length += 4;\n\t\t\t\t\n\t\t\t\tif (strings_buffer.length - strings_buffer_length < str_buf_length) {\n\t\t\t\t\tstrings_buffer = Buffer.concat([strings_buffer, new Buffer(4096)]);\n\t\t\t\t}\n\t\t\t\tstr_buf.copy(strings_buffer, strings_buffer_length);\n\t\t\t\tstrings_buffer_length += str_buf_length;\n\t\t\t}\n\t\t}))\n\t\t.on('error', e=>callback(e))\n\t\t.on('end', ()=>{\n\t\t\tcallback(null, new SplitSnapshotProvider(\n\t\t\t\tsnapshot_info,\n\t\t\t\tnodes_buffer,\n\t\t\t\tedges_buffer,\n\t\t\t\tsamples_buffer,\n\t\t\t\tstrings_indices_buffer,\n\t\t\t\tstrings_buffer\n\t\t\t\t)\n\t\t\t);\n\t\t});\n\t}\n}"
  },
  {
    "__docId__": 22,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "SplitSnapshotProvider",
    "memberof": "lib/SplitSnapshotProvider.js",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "access": null,
    "export": true,
    "importPath": "snapshot-utils/lib/SplitSnapshotProvider.js",
    "importStyle": "SplitSnapshotProvider",
    "description": "An implementation of working directly with snapshot data, not meant for dev consumption.\nThis implementation uses Synchronous file APIs",
    "lineNumber": 9,
    "interface": false
  },
  {
    "__docId__": 23,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#constructor",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "snapshot_info",
        "description": "Meta information required for understanding a snapshot"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "node_buffer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "edge_buffer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "string_indices_buffer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "string_buffer",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 24,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "snapshot",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#snapshot",
    "access": "private",
    "description": null,
    "lineNumber": 29,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 25,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "node_fields_length",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#node_fields_length",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "node_arr_length",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#node_arr_length",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 27,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "node_struct_size",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#node_struct_size",
    "access": "private",
    "description": null,
    "lineNumber": 43,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "node_buffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#node_buffer",
    "access": "private",
    "description": null,
    "lineNumber": 47,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 29,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "edge_fields_length",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#edge_fields_length",
    "access": "private",
    "description": null,
    "lineNumber": 55,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 30,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "edge_arr_length",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#edge_arr_length",
    "access": "private",
    "description": null,
    "lineNumber": 59,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 31,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "edge_struct_size",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#edge_struct_size",
    "access": "private",
    "description": null,
    "lineNumber": 64,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 32,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "edge_buffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#edge_buffer",
    "access": "private",
    "description": null,
    "lineNumber": 68,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 33,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "sample_struct_size",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#sample_struct_size",
    "access": "private",
    "description": null,
    "lineNumber": 76,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 34,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "sample_arr_length",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#sample_arr_length",
    "access": "private",
    "description": null,
    "lineNumber": 80,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 35,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "sample_buffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#sample_buffer",
    "access": "private",
    "description": null,
    "lineNumber": 84,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "string_indices_buffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#string_indices_buffer",
    "access": "private",
    "description": null,
    "lineNumber": 89,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 37,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "strings_buffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#strings_buffer",
    "access": "private",
    "description": null,
    "lineNumber": 93,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "string_index_struct_size",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#string_index_struct_size",
    "access": "private",
    "description": null,
    "lineNumber": 98,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 39,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getNodeArraySize",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getNodeArraySize",
    "access": null,
    "description": "Get total number of Nodes",
    "lineNumber": 106,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 40,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getNodeBuffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getNodeBuffer",
    "access": null,
    "description": "Get the buffer for a Node at the specified index",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 41,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getEdgeArraySize",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getEdgeArraySize",
    "access": null,
    "description": "Get total number of Edges",
    "lineNumber": 133,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 42,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getEdgeBuffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getEdgeBuffer",
    "access": null,
    "description": "Get the buffer for an Edge at the specified index",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 43,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSampleArraySize",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getSampleArraySize",
    "access": null,
    "description": "Get total number of Samples",
    "lineNumber": 160,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 44,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSampleBuffer",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getSampleBuffer",
    "access": null,
    "description": "Gets a sample at the specified index.",
    "lineNumber": 170,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": "Index of the sample we wish to get."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 45,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getString",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getString",
    "access": null,
    "description": "Gets a string at the specified index.",
    "lineNumber": 184,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": "Index of the string we wish to get."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 46,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getMeta",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#getMeta",
    "access": null,
    "description": null,
    "lineNumber": 201,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Metadata from the snapshot data required to find Node and Field structure."
    },
    "generator": false
  },
  {
    "__docId__": 47,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "writeToDirectory",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider#writeToDirectory",
    "access": null,
    "description": "Convenience method for saving snapshot data in a faster loading format to a directory",
    "lineNumber": 211,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "outdir",
        "description": "Path of the directory to save to"
      },
      {
        "nullable": null,
        "types": [
          "function(err: *)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "Callback notified when there is an error or completion"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 48,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "fromDirectory",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider.fromDirectory",
    "access": null,
    "description": "Convenience method for loading snapshot data from a directory",
    "lineNumber": 248,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "outdir",
        "description": "Path of the directory to load"
      },
      {
        "nullable": null,
        "types": [
          "function(err: *, provider: SplitSnapshotProvider)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "Callback notified when there is an error or completion"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 49,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "fromStream",
    "memberof": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider",
    "longname": "lib/SplitSnapshotProvider.js~SplitSnapshotProvider.fromStream",
    "access": null,
    "description": "Convenience method for loading snapshot data from a stream",
    "lineNumber": 345,
    "params": [
      {
        "nullable": null,
        "types": [
          "Stream"
        ],
        "spread": false,
        "optional": false,
        "name": "stream",
        "description": "Path of the directory to load"
      },
      {
        "nullable": null,
        "types": [
          "function(err: *, provider: SplitSnapshotProvider)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "Callback notified when there is an error or completion"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 50,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/bin/closed-size.js",
    "memberof": null,
    "longname": "lib/bin/closed-size.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import {HeapSnapshot,SplitSnapshotProvider} from \"../\";\n\n// We are going to use stdin to read our snapshot\n// pipe a snapshot in via: `node script-vars.js <\"my.heapsnapshot\"`\nconst stream = process.stdin;\n\n// This is used to parse the snapshot data.\n// A provider is generally not used for analyzing the snapshot.\n// It is an abstraction to allow saving/loading the snapshot to different\n// location.\nSplitSnapshotProvider.fromStream(stream, (err, provider) => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\tprocess.exit(1);\n\t}\n\t// This gives us an API that can be used to analyze the snapshot.\n\t// Since snapshot data contains the structure of Nodes and Edges\n\t// the Node and Edge classes we obtain from this may be different\n\t// from different snapshots.\n\tconst snapshot = new HeapSnapshot(provider);\n\t\n\tconst path = [];\n\t\n\t// setup the walk\n\tconst iter = snapshot.walk({\n\t\tonNodeOpen,\n\t\tonNodeSkipped,\n\t\tonNodeClose\n\t});\n\t\n\tfunction allClosedParentChildSets() {\n\t\tlet i = path.length - 1;\n\t\tfor (; i > 0; i++) {\n\t\t\tif (path[i].fields.type === 'closure') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn path.slice(i).map(n => contains.get(_id(n)));\n\t}\n\t\n\tfunction _id(node) {\n\t\treturn node.fields.id;\n\t}\n\tconst commited = new Set();\n\tconst vis_nodes = new Map();\n\t// uncommited => [children waiting]\n\tconst pending_commit_nodes = new Map();\n\tfunction commit(id) {\n\t\tcommited.add(id);\n\t\tconst newly_commited = vis_nodes.get(id).commited || new Set();\n\t\t// console.log(id, 'commited to', newly_commited);\n\t\tif (pending_commit_nodes.has(id)) {\n\t\t\tfor (const waiting_id of pending_commit_nodes.get(id)) {\n\t\t\t\t// console.log(id, 'notifying', waiting_id);\n\t\t\t\tconst waiting_vis_node = vis_nodes.get(waiting_id);\n\t\t\t\twaiting_vis_node.notify(id, newly_commited);\n\t\t\t}\n\t\t}\n\t}\n\tfunction wait(id, pending_id) {\n\t\tif (commited.has(pending_id)) {\n\t\t\tthrow new Error('pending id is already commited');\n\t\t}\n\t\t// console.log(id, 'waiting on', pending_id);\n\t\tif (!pending_commit_nodes.has(pending_id)) {\n\t\t\tpending_commit_nodes.set(pending_id, new Set());\n\t\t}\n\t\tpending_commit_nodes.get(pending_id).add(id);\n\t}\n\tfunction onNodeOpen(node) {\n\t\tconsole.log(node.fields)\n\t\tconst id = _id(node);\n\t\tconst vis_node = new VisibilityNode(id, wait, commit);\n\t\tvis_nodes.set(id, vis_node);\n\t\tpath.push(vis_node);\n\t}\n\tfunction onNodeSkipped(node) {\n\t\tconst id = _id(node);\n\t\tif (path.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\t// grab the eventual or existing value\n\t\t// append to self\n\t\tconst vis_node = path[path.length - 1];\n\t\tif (commited.has(id)) {\n\t\t\tvis_node.add(vis_nodes.get(id));\n\t\t}\n\t\telse {\n\t\t\tvis_node.wait(id);\n\t\t}\n\t}\n\tfunction onNodeClose(node) {\n\t\tconst vis_node = path.pop();\n\t\tconst id = _id(node);\n\t\tvis_node.close();\n\t\tif (vis_node.isReadyToCommit()) {\n\t\t\tvis_node.commit();\n\t\t}\n\t\tif (path.length > 0) {\n\t\t\tconst parent = path[path.length - 1];\n\t\t\tparent.add(vis_node);\n\t\t}\n\t}\n\t\n\t// perform the walk, we don't need to process it in chunks for the example\n\tfor (const _ of iter) {}\n\t\n\tfor(const [id,vis_node] of vis_nodes.entries()) {\n\t\tif (vis_node && vis_node.commited) console.log(id, Array.from(vis_node.commited));\n\t\telse console.log(id)\n\t}\n});\n\nclass VisibilityNode {\n\tconstructor(id, wait, commit) {\n\t\tthis.id = id;\n\t\tthis._wait = wait;\n\t\tthis._commit = commit;\n\t\tthis.closed = false;\n\t\tthis.commited = null;// = new Set();\n\t\tthis.pending = null;// = new Set();\n\t}\n\tadd(vis_node) {\n\t\tif (this.closed) {\n\t\t\tthrow new EvalError('already closed');\n\t\t}\n\t\tif (!this.commited) {\n\t\t\tthis.commited = new Set();\n\t\t}\n\t\tthis.commited.add(vis_node.id);\n\t\tif (vis_node.commited) {\n\t\t\tfor (const commited_id of vis_node.commited) {\n\t\t\t\tif (commited_id != this.id) {\n\t\t\t\t\tthis.commited.add(commited_id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (vis_node.pending) {\n\t\t\tfor (const pending_id of vis_node.pending) {\n\t\t\t\tthis.wait(pending_id);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tnotify(pending_id, commited_ids) {\n\t\tthis.pending.delete(pending_id);\n\t\tif (!this.commited) {\n\t\t\tthis.commited = new Set();\n\t\t}\n\t\tthis.commited.add(pending_id);\n\t\tfor (const commited_id of commited_ids) {\n\t\t\tif (commited_id != this.id) {\n\t\t\t\tthis.commited.add(commited_id);\n\t\t\t}\n\t\t}\n\t\tif (this.isReadyToCommit()) {\n\t\t\tthis.commit();\n\t\t}\n\t}\n\t\n\twait(pending_id) {\n\t\tif (this.closed) {\n\t\t\tthrow new EvalError('already closed');\n\t\t}\n\t\tif (pending_id != this.id) {\n\t\t\tif (!this.pending) {\n\t\t\t\tthis.pending = new Set();\n\t\t\t}\n\t\t\tthis.pending.add(pending_id);\n\t\t\tthis._wait(this.id, pending_id);\n\t\t}\n\t}\n\tclose() {\n\t\tthis.closed = true;\n\t}\n\tisReadyToCommit() {\n\t\treturn this.closed && (this.pending ? this.pending.size === 0 : true);\n\t}\n\tcommit() {\n\t\tif (!this.isReadyToCommit()) {\n\t\t\tthrow new EvalError(\"unable to commit\");\n\t\t}\n\t\tthis._commit(this.id);\n\t}\n}"
  },
  {
    "__docId__": 51,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stream",
    "memberof": "lib/bin/closed-size.js",
    "longname": "lib/bin/closed-size.js~stream",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/closed-size.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "VisibilityNode",
    "memberof": "lib/bin/closed-size.js",
    "longname": "lib/bin/closed-size.js~VisibilityNode",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/closed-size.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 53,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#constructor",
    "access": null,
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "params": [
      {
        "name": "id",
        "types": [
          "*"
        ]
      },
      {
        "name": "wait",
        "types": [
          "*"
        ]
      },
      {
        "name": "commit",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 54,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "id",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#id",
    "access": null,
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_wait",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#_wait",
    "access": null,
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_commit",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#_commit",
    "access": null,
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "closed",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#closed",
    "access": null,
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "commited",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#commited",
    "access": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "pending",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#pending",
    "access": null,
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "add",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#add",
    "access": null,
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "params": [
      {
        "name": "vis_node",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 61,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "commited",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#commited",
    "access": null,
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "notify",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#notify",
    "access": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "pending_id",
        "types": [
          "*"
        ]
      },
      {
        "name": "commited_ids",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 63,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "commited",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#commited",
    "access": null,
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "wait",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#wait",
    "access": null,
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "params": [
      {
        "name": "pending_id",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 65,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "pending",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#pending",
    "access": null,
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "close",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#close",
    "access": null,
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 67,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "closed",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#closed",
    "access": null,
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "isReadyToCommit",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#isReadyToCommit",
    "access": null,
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 69,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "commit",
    "memberof": "lib/bin/closed-size.js~VisibilityNode",
    "longname": "lib/bin/closed-size.js~VisibilityNode#commit",
    "access": null,
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 70,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/bin/dominators.js",
    "memberof": null,
    "longname": "lib/bin/dominators.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import {HeapSnapshot,SplitSnapshotProvider} from \"../\";\n\n// We are going to use stdin to read our snapshot\n// pipe a snapshot in via: `node dump.js <\"my.heapsnapshot\"`\nconst stream = process.stdin;\n\n// This is used to parse the snapshot data.\n// A provider is generally not used for analyzing the snapshot.\n// It is an abstraction to allow saving/loading the snapshot to different\n// location.\nSplitSnapshotProvider.fromStream(stream, (err, provider) => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\tprocess.exit(1);\n\t}\n\t// This gives us an API that can be used to analyze the snapshot.\n\t// Since snapshot data contains the structure of Nodes and Edges\n\t// the Node and Edge classes we obtain from this may be different\n\t// from different snapshots.\n\tconst snapshot = new HeapSnapshot(provider);\n\t\n\tconst path = [];\n\t\n\tlet tree = null;\n\tconst lookup = new Map();\n\tconst $id = node => node.fields.id;\n\tfunction integrate(id) {\n\t\tif (tree == null) {\n\t\t\ttree = new DominatorTreeNode(null, id);\n\t\t\tlookup.set(id, tree);\n\t\t\treturn;\n\t\t}\n\t\tlet parent_id = path.length - 1;\n\t\tlet node = new DominatorTreeNode(path[parent_id], id);\n\t\tlookup.set(id, node);\n\t}\n\t// we only ever need to reduce to immediate dominator,\n\t// but! me must adjust any current immediate dominator as well\n\tfunction reduce(id, max_path = path.length) {\n\t\tlet subpath = path.slice(0, max_path);\n\t\tlet dominator = lookup.get(id).parent;\n\t\tlet adjusting = [id];\n\t\twhile (lookup.has(dominator)) {\n\t\t\tlet index = subpath.indexOf(dominator);\n\t\t\tif (index >= 0) {\n\t\t\t\tfor (const node_id of adjusting) {\n\t\t\t\t\tlookup.get(node_id).parent = dominator;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadjusting.push(dominator);\n\t\t\tdominator = lookup.get(dominator).parent;\n\t\t}\n\t}\n\t\n\t// setup the walk\n\tconst iter = snapshot.walk({\n\t\t// first time we encounter a node we need to add\n\t\t// the full path to the dominator tree\n\t\tonNodeOpen(node) {\n\t\t\tconst id = $id(node);\n\t\t\tintegrate(id);\n\t\t\tpath.push(id);\n\t\t},\n\t\t// when we encounter a node we have already seen\n\t\t// we only need to reduce the dominator tree\n\t\tonNodeSkipped(node) {\n\t\t\tconst id = $id(node);\n\t\t\treduce(id);\n\t\t},\n\t\tonNodeClose(node) {\n\t\t\tpath.pop(node);\n\t\t}\n\t});\n\t// perform the walk\n\tfor (const _ of iter) {}\n\t\n\t// print our lovely data\n\tfor (const node of lookup.values()) {\n\t\tlet ret = `${node.id}`;\n\t\tlet parent_id = node.parent;\n\t\twhile (parent_id != null && lookup.has(parent_id)) {\n\t\t\tret += `->${parent_id}`;\n\t\t\tparent_id = lookup.get(parent_id).parent;\n\t\t}\n\t\tconsole.log(ret);\n\t}\n});\n\nclass DominatorTreeNode {\n\tconstructor(parent, id) {\n\t\tthis.parent = parent;\n\t\tthis.id = id;\n\t}\n}"
  },
  {
    "__docId__": 71,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stream",
    "memberof": "lib/bin/dominators.js",
    "longname": "lib/bin/dominators.js~stream",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/dominators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "DominatorTreeNode",
    "memberof": "lib/bin/dominators.js",
    "longname": "lib/bin/dominators.js~DominatorTreeNode",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/dominators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 73,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "lib/bin/dominators.js~DominatorTreeNode",
    "longname": "lib/bin/dominators.js~DominatorTreeNode#constructor",
    "access": null,
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [
      {
        "name": "parent",
        "types": [
          "*"
        ]
      },
      {
        "name": "id",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 74,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "parent",
    "memberof": "lib/bin/dominators.js~DominatorTreeNode",
    "longname": "lib/bin/dominators.js~DominatorTreeNode#parent",
    "access": null,
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "id",
    "memberof": "lib/bin/dominators.js~DominatorTreeNode",
    "longname": "lib/bin/dominators.js~DominatorTreeNode#id",
    "access": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/bin/dump.js",
    "memberof": null,
    "longname": "lib/bin/dump.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import {HeapSnapshot,SplitSnapshotProvider} from \"../\";\n\n// We are going to use stdin to read our snapshot\n// pipe a snapshot in via: `node dump.js <\"my.heapsnapshot\"`\nconst stream = process.stdin;\n\n// This is used to parse the snapshot data.\n// A provider is generally not used for analyzing the snapshot.\n// It is an abstraction to allow saving/loading the snapshot to different\n// location.\nSplitSnapshotProvider.fromStream(stream, (err, provider) => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\tprocess.exit(1);\n\t}\n\t// This gives us an API that can be used to analyze the snapshot.\n\t// Since snapshot data contains the structure of Nodes and Edges\n\t// the Node and Edge classes we obtain from this may be different\n\t// from different snapshots.\n\tconst snapshot = new HeapSnapshot(provider);\n\t\n\t// setup the walk\n\tconst iter = snapshot.walk({\n\t\tonNodeOpen(node) { console.log(node) },\n\t\tonEdge(edge) {},\n\t\tonNodeClose(node) {}\n\t});\n\t// perform the walk\n\tfor (const _ of iter) {}\n});"
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stream",
    "memberof": "lib/bin/dump.js",
    "longname": "lib/bin/dump.js~stream",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/dump.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/bin/id.js",
    "memberof": null,
    "longname": "lib/bin/id.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import {HeapSnapshot,SplitSnapshotProvider} from \"../\";\n\n// We are going to use stdin to read our snapshot\n// pipe a snapshot in via: `node dump.js <\"my.heapsnapshot\"`\nconst stream = process.stdin;\n\n// This is used to parse the snapshot data.\n// A provider is generally not used for analyzing the snapshot.\n// It is an abstraction to allow saving/loading the snapshot to different\n// location.\nSplitSnapshotProvider.fromStream(stream, (err, provider) => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\tprocess.exit(1);\n\t}\n\t// This gives us an API that can be used to analyze the snapshot.\n\t// Since snapshot data contains the structure of Nodes and Edges\n\t// the Node and Edge classes we obtain from this may be different\n\t// from different snapshots.\n\tconst snapshot = new HeapSnapshot(provider);\n\t\n  console.log(snapshot.getNodeById(3));\n});\n"
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stream",
    "memberof": "lib/bin/id.js",
    "longname": "lib/bin/id.js~stream",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/id.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/bin/samples.js",
    "memberof": null,
    "longname": "lib/bin/samples.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import {HeapSnapshot,SplitSnapshotProvider} from \"../\";\n\n// We are going to use stdin to read our snapshot\n// pipe a snapshot in via: `node dump.js <\"my.heapsnapshot\"`\nconst stream = process.stdin;\n\n// This is used to parse the snapshot data.\n// A provider is generally not used for analyzing the snapshot.\n// It is an abstraction to allow saving/loading the snapshot to different\n// location.\nSplitSnapshotProvider.fromStream(stream, (err, provider) => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\tprocess.exit(1);\n\t}\n\t// This gives us an API that can be used to analyze the snapshot.\n\t// Since snapshot data contains the structure of Nodes and Edges\n\t// the Node and Edge classes we obtain from this may be different\n\t// from different snapshots.\n\tconst snapshot = new HeapSnapshot(provider);\n\t\n\t// perform the walk\n\tfor (const sample of snapshot.samples()) {\n\t\tconsole.log(sample);\n\t}\n});"
  },
  {
    "__docId__": 81,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stream",
    "memberof": "lib/bin/samples.js",
    "longname": "lib/bin/samples.js~stream",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/samples.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/bin/save-to-dir.js",
    "memberof": null,
    "longname": "lib/bin/save-to-dir.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import SplitSnapshotProvider from \"../SplitSnapshotProvider\";\nimport path from \"path\";\nimport fs from \"fs\";\n\nconst outdir = path.normalize(process.argv[2])\nif (!path.isAbsolute(outdir)) {\n\tconsole.error('You must specify an absolute path for outdir');\n\tprocess.exit(3);\n}\n\nSplitSnapshotProvider.fromStream(process.stdin, function (err, provider) {\n  provider.writeToDirectory(outdir, _=>_);\n})"
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "outdir",
    "memberof": "lib/bin/save-to-dir.js",
    "longname": "lib/bin/save-to-dir.js~outdir",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/save-to-dir.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/bin/script-vars.js",
    "memberof": null,
    "longname": "lib/bin/script-vars.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import {HeapSnapshot,SplitSnapshotProvider} from \"../\";\n\n// We are going to use stdin to read our snapshot\n// pipe a snapshot in via: `node script-vars.js <\"my.heapsnapshot\"`\nconst stream = process.stdin;\n\n// This is used to parse the snapshot data.\n// A provider is generally not used for analyzing the snapshot.\n// It is an abstraction to allow saving/loading the snapshot to different\n// location.\nSplitSnapshotProvider.fromStream(stream, (err, provider) => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\tprocess.exit(1);\n\t}\n\t// This gives us an API that can be used to analyze the snapshot.\n\t// Since snapshot data contains the structure of Nodes and Edges\n\t// the Node and Edge classes we obtain from this may be different\n\t// from different snapshots.\n\tconst snapshot = new HeapSnapshot(provider);\n\t\n\t// we will keep a list of all the globals we have seen and visit them at the end\n\t// this is because global Nodes have a type of \"object\" and can be confused easily\n\t// unless we grab them from context Nodes\n\tconst globals = new Set();\n\t\n\t// setup the walk\n\tconst iter = snapshot.walk({\n\t\tonNodeOpen\n\t});\n\t\n\t// perform the walk, we don't need to process it in chunks for the example\n\tfor (const _ of iter) {}\n\t\n\tfunction onNodeOpen(node) {\n\t\tif (node.fields.type === 'closure') {\n\t\t\t// Store information that we want to print out\n\t\t\t// This is because the information is split up\n\t\t\t// and we want to have all of it at once\n\t\t\tconst vars = [];\n\t\t\tlet script = null;\n\t\t\tlet global = null;\n\t\t\tfor (const edge of node.walkEdges()) {\n\t\t\t\t// closures that have variables create context Nodes\n\t\t\t\t// these will list all the variables that a closure\n\t\t\t\t// uses. unused variables are not listed.\n\t\t\t\tif (edge.fields.name_or_index === 'context') {\n\t\t\t\t\tfor (const context_edge of edge.getNode().walkEdges()) {\n\t\t\t\t\t\t// context Nodes have Edges with a type of \"context\"\n\t\t\t\t\t\t// to represent where variables are\n\t\t\t\t\t\tif (context_edge.fields.type === 'context') {\n\t\t\t\t\t\t\t// grab the name of the variable and\n\t\t\t\t\t\t\t// the id of the Node that is in the variable\n\t\t\t\t\t\t\tconst name = context_edge.fields.name_or_index;\n\t\t\t\t\t\t\tconst val_id = context_edge.getNode().fields.id;\n\t\t\t\t\t\t\tvars.push(`${name} = @${val_id}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// context Nodes always keep track of the global they\n\t\t\t\t\t\t// are attached to, just like frames in a browser\n\t\t\t\t\t\t// there can be multiple globals\n\t\t\t\t\t\telse if (context_edge.fields.type === 'internal'\n\t\t\t\t\t\t&& context_edge.fields.name_or_index === 'global') {\n\t\t\t\t\t\t\t// it is easier to lookup Nodes by index than id\n\t\t\t\t\t\t\tglobals.add(context_edge.fields.to_node);\n\t\t\t\t\t\t\tglobal = context_edge.getNode().fields.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// closures have what is called shared script information\n\t\t\t\t// this information is shared between *all* instances of a\n\t\t\t\t// function and includes things like what script the closure\n\t\t\t\t// was from\n\t\t\t\tif (edge.fields.name_or_index === 'shared') {\n\t\t\t\t\tfor (const shared_edge of edge.getNode().walkEdges()) {\n\t\t\t\t\t\tif (shared_edge.fields.name_or_index === 'script') {\n\t\t\t\t\t\t\tscript = shared_edge.getNode().fields.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// print our closure data!\n\t\t\tfor (const line of vars) {\n\t\t\t\tif (script != null) {\n\t\t\t\t\tconsole.log(`${line} in function ${node.fields.name} in script ${script} in global @${global}`)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.log(`${line} in global @${global}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// next we walk all of the global objects we saw\n\tfor (const global_index of globals) {\n\t\tlet node = snapshot.getNode(global_index);\n\t\tfor (const edge of node.walkEdges()) {\n\t\t\tif (edge.fields.type === 'property') {\n\t\t\t\tconst property_node = edge.getNode();\n\t\t\t\tconsole.log(`${edge.fields.name_or_index} = @${property_node.fields.id} on global @${node.fields.id}`)\n\t\t\t}\n\t\t}\n\t}\n});"
  },
  {
    "__docId__": 85,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stream",
    "memberof": "lib/bin/script-vars.js",
    "longname": "lib/bin/script-vars.js~stream",
    "access": null,
    "export": false,
    "importPath": "snapshot-utils/lib/bin/script-vars.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/index.js",
    "memberof": null,
    "longname": "lib/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import HeapSnapshot from \"./HeapSnapshot\";\nimport SplitSnapshotProvider from \"./SplitSnapshotProvider\";\nexport {HeapSnapshot,SplitSnapshotProvider};"
  },
  {
    "__docId__": 87,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/parseSnapshotStream.js",
    "memberof": null,
    "longname": "lib/parseSnapshotStream.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import clarinet from \"clarinet\";\n/**\n * @typedef {Object} parseSnapshotStreamCallbacks\n * @property {function(snapshot_info: {meta:Object})} onsnapshot_info\n * @property {function(node_buffer: Buffer)} onnode\n * @property {function(edge_buffer: Buffer)} onedge\n * @property {function(sample_buffer: Buffer)} onsample\n * @property {function(str: string)} onstring\n */\n/**\n * Create a writable stream for parsing JSON.\n * \n * @param parseSnapshotStreamCallbacks callbacks t\n * @return {undefined}\n */\nexport default function parseSnapshotStream({\n\tonsnapshot_info = Function.prototype,\n\tonnode = Function.prototype,\n\tonedge = Function.prototype,\n\tonstring = Function.prototype,\n  onsample = Function.prototype,\n  ontracefninfo = Function.prototype,\n  // (buffer, [push,pop]) push\n  ontraceframe_and_state = Function.prototype\n}) {\n  const parser = clarinet.createStream();\n\n  const parser_keys = [];\n  const key = (k) => {\n    return parser_keys.push(k);\n  }\n\tconst unkey = () => {\n    return parser_keys.pop();\n  }\n\n  const parser_path = [];\n  const push = (value) => {\n    if (parser_path.length) {\n      const target = parser_path[parser_path.length - 1];\n      const field = parser_keys[parser_keys.length - 1];\n      if (Array.isArray(target)) {\n          parser_keys[parser_keys.length - 1]++;\n      }\n      target[field] = value;\n    }\n    else {\n      parser_path.push(value);\n    }\n  }\n  const nest = (value) => {\n    let first = parser_path.length === 0;\n    push(value);\n    if (!first) parser_path.push(value);\n  }\n  const pop = () => {\n    return parser_path.pop();\n  }\n\n\tlet node_fields_size = 0;\n\tlet edge_fields_size = 0;\n  let field_index = 0;\n  let buffer = null;\n\tlet innodes = false;\n\tlet inedges = false;\n\tlet instrings = false;\n\tlet insamples = false;\n\tconst atsnapshot = () => {\n\t\treturn parser_keys.length === 1 && parser_keys[0] === 'snapshot';\n\t};\n\tconst insnapshot = () => {\n\t\treturn parser_keys.length >= 1 && parser_keys[0] === 'snapshot';\n\t};\n\tconst atnodes = () => {\n\t\treturn parser_keys.length === 1 && parser_keys[0] === 'nodes';\n\t};\n\tconst atedges = () => {\n\t\treturn parser_keys.length === 1 && parser_keys[0] === 'edges';\n\t};\n\tconst atsamples = () => {\n\t\treturn parser_keys.length === 1 && parser_keys[0] === 'samples';\n\t};\n\tconst atstrings = () => {\n\t\treturn parser_keys.length === 1 && parser_keys[0] === 'strings';\n\t};\n  parser.on(\"openobject\", (first_key) => {\n    if (insnapshot()) nest({});\n    if (typeof first_key === 'string') key(first_key);\n    else key(undefined);\n  });\n  parser.on(\"closeobject\", () => {\n    unkey();\n    if (atsnapshot()) {\n      const snapshot = pop();\n      node_fields_size = snapshot.meta.node_fields.length * 4;\n      edge_fields_size = snapshot.meta.edge_fields.length * 4;\n      onsnapshot_info(snapshot);\n    }\n    else if (insnapshot()) pop();\n  });\n  parser.on(\"openarray\", () => {\n    if (insnapshot()) nest([]);\n    else if (atnodes()) {\n      innodes = true;\n      buffer = new Buffer(node_fields_size);\n      field_index = 0;\n    }\n    else if (atedges()) {\n      inedges = true;\n      buffer = new Buffer(edge_fields_size);\n      field_index = 0;\n    }\n    else if (atsamples()) {\n      insamples = true;\n      buffer = new Buffer(4 * 2);\n      field_index = 0;\n    }\n    else if (atstrings()) {\n      instrings = true;\n    }\n    key(0);\n  });\n  parser.on(\"closearray\", () => {\n    unkey();\n    if (insnapshot()) pop();\n    else if (atnodes()) {\n      innodes = false;\n      onnode(null);\n    }\n    else if (atedges()) {\n      inedges = false;\n      onedge(null);\n    }\n    else if (atsamples()) {\n      insamples = false;\n      onsample(null);\n    }\n    else if (atstrings()) {\n      instrings = false;\n      onstring(null);\n    }\n  });\n  parser.on(\"key\", (new_key) => {\n    unkey();\n    key(new_key);\n  });\n  parser.on(\"value\", (value) => {\n    if (innodes) {\n      buffer.writeUInt32BE(value, field_index);\n      field_index = (field_index + 4) % node_fields_size;\n      if (field_index === 0) {\n        onnode(buffer);\n        buffer = new Buffer(node_fields_size);\n      }\n    }\n    else if (inedges) {\n      buffer.writeUInt32BE(value, field_index);\n      field_index = (field_index + 4) % edge_fields_size;\n      if (field_index === 0) {\n        onedge(buffer);\n        buffer = new Buffer(edge_fields_size);\n      }\n    }\n    else if (insamples) {\n      buffer.writeUInt32BE(value, field_index);\n      field_index = (field_index + 4) % (4 * 2);\n      if (field_index === 0) {\n        onsample(buffer);\n        buffer = new Buffer(4 * 2);\n      }\n    }\n    else if (instrings) {\n      onstring(value);\n    }\n    else if (insnapshot()) push(value);\n  });\n\treturn parser;\n}\n"
  },
  {
    "__docId__": 88,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "parseSnapshotStreamCallbacks",
    "memberof": "lib/parseSnapshotStream.js",
    "longname": "lib/parseSnapshotStream.js~parseSnapshotStreamCallbacks",
    "access": null,
    "description": null,
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(snapshot_info: {meta:Object})"
        ],
        "spread": false,
        "optional": false,
        "name": "onsnapshot_info",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function(node_buffer: Buffer)"
        ],
        "spread": false,
        "optional": false,
        "name": "onnode",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function(edge_buffer: Buffer)"
        ],
        "spread": false,
        "optional": false,
        "name": "onedge",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function(sample_buffer: Buffer)"
        ],
        "spread": false,
        "optional": false,
        "name": "onsample",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function(str: string)"
        ],
        "spread": false,
        "optional": false,
        "name": "onstring",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "parseSnapshotStreamCallbacks"
    }
  },
  {
    "__docId__": 89,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseSnapshotStream",
    "memberof": "lib/parseSnapshotStream.js",
    "longname": "lib/parseSnapshotStream.js~parseSnapshotStream",
    "access": null,
    "export": true,
    "importPath": "snapshot-utils/lib/parseSnapshotStream.js",
    "importStyle": "parseSnapshotStream",
    "description": "Create a writable stream for parsing JSON.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "parseSnapshotStreamCallbacks",
        "description": "callbacks t"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 91,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 92,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 93,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 94,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 95,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 96,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 97,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 98,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 99,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 100,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 101,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 102,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 103,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 104,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 105,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 106,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 107,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 108,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 109,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 110,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 111,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 112,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 113,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 114,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 115,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 116,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 117,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 118,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 119,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 120,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 121,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 122,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 123,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 124,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 125,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 126,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 127,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 128,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 129,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 130,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 131,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 132,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 133,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 134,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 135,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 136,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 137,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 139,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 140,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 141,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 142,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 143,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 144,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 145,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 146,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": null,
    "builtinExternal": true
  }
]